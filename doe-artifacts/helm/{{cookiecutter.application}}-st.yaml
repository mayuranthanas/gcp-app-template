# Default values for helm-chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
applicationName: "{{cookiecutter.application}}"
environment: np
replicaCount: 1
namespace: "{{cookiecutter.namespace}}"
type: deployment

containerPort: {{cookiecutter.port}}

#set to true if deploying to openshift and want a route created
openshift:
  enabled: false

#TELUS Labels/Annotations
telus:
  cmdbId: "{{cookiecutter.cmdbId}}"
  costCentre: "{{cookiecutter.costCentre}}"
  organization: "{{cookiecutter.organization}}"
  mailingList: "{{cookiecutter.mailingList}}"

# Allows you set arbitrary env variables.
#extraEnvs: 
#  - name: envname
#    value: envvalue
#  - name: envname2
#    value: envvalue2 

envFrom: []
# envFrom:
#   - secretRef:
#       name: test-secret
#   - configMapRef:
#       name: special-config

# Allows you to add any config files and specify a path location in the volumeMounts
# such as application.yaml or log4j2.properties.  Since this is clear in src control
# please do no use for sensitive data such as keys and passwords.  See Secrets.
# configmaps: 
#   key:
#     properties:
#       key: "value"
#       key2: "value"
#   file:
#     application.yaml: |
#       key:
#         nestedkey: value
#     log4j2.properties: |
#       key = value

#initContainers: |
#  - name: init-myservice
#    image: busybox:1.28
#    command: ['sh', '-c', "until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done"]
#  - name: init-mydb
#    image: busybox:1.28
#    command: ['sh', '-c', "until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done"]  

# If you add a configmap you must add a volume names "configmap" to mount to a path of your choosing
# you can also mount arbitrary volumes or otherwise leave as an empty array
volumeMounts: []
#volumeMounts: 
#  - name: configmap
#    path: /etc/config
#  - name: cache-dir
#    path: /etc/cache
#  - name: test-volume
#    path: /etc/gce-pd


livenessProbe: 
  httpGet:
    path: /
    port: {{cookiecutter.port}}
    # httpHeaders:
    #   - name: Authorization
    #     value: Basic dGVjaGh1YjpwYXNzdzByZA==

readinessProbe: 
  httpGet:
    path: /
    port: {{cookiecutter.port}}
    # httpHeaders:
    #   - name: Authorization
    #     value: Basic dGVjaGh1YjpwYXNzdzByZA==

# Volume mounts should have an equivelent volume name defined of required type
# this example creates and emptyDir type volume for ephemeral data
# volumes: |
#   - name: cache-dir
#     emtptyDir: {}
#   - name: test-volume
    # This GCE PD must already exist.
#     gcePersistentDisk:
#      pdName: my-data-disk
#      fsType: ext4

# Mount precreated secrets to a volume, it is determined the helm chart should not create secrets
# to protect security.  Please do not store secret data such as keys, keystores or passwords in Git
# or in a configmap
secretMounts: []
#secretMounts:
#  - name: keystores
#    secretName: app-keystores
#    path: /etc/secrets/keystores

image:
  repository: gcr.io/cio-gke-devops-e4993356/{{cookiecutter.namespace}}/{{cookiecutter.application}}
  tag: latest
  pullPolicy: Always  # IfNotPresent

service:
  type: ClusterIP
  port: {{ cookiecutter.port }}

ingress:
  enabled: true
  path: /?(.*)
  hosts:
    - "{{cookiecutter.hostnameNp}}"
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

  class: nginx-ingress-protected

 # Can disable modsecurity rule 949110 via annotation below to prevent 403 errors common in either of the following cases:
 #    - You wish to allow PUT/DELETE HTTP methods
 #    - Consumers must make repeated requests, to prevent "Inbound Anomaly Score Exceeded" (ie React UIs).

  annotations:
    nginx.ingress.kubernetes.io/modsecurity-snippet: SecRuleRemoveByID 949110


# enable on kong ingress and add plugins
# insure the hostname used is cname to the kong ingress A record.
  # class: kong
  # kongPlugins: key-auth
    
# create required kong plugins
# plugins are reusable within namespace
#kong:
#  enabled: false
#  plugins:
#    - name: key-auth
#      plugin: key-auth
#      config: 
#        key_names: apikey
  #   - name: acl
  #     plugin: acl
  #     config:
  #       name: test
  # consumers:
  #   - name: testconsumer
  #     username: test
  # credentials:
  #   - name: testcredential
  #     consumer: testconsumer
  #     type: key-auth
# add any additional credential config as required by type. 
# key for key-auth is autogenerated and can be seen via kubectl get kongcredential...
      # config:
      #   key: value
# Add custom kong ingress settings
#  ingress:
#    upstream:
  #     healthchecks:
  #       passive:
  #         healthy:
  #           http_statuses:
  #           - 200
  #           successes: 0
  #         unhealthy:
  #           http_failures: 0
  #           http_statuses:
  #           - 429
  #           - 503
  #           tcp_failures: 0
  #           timeouts: 0
#    proxy:
  #     protocol: http
  #     path: /
  #     connect_timeout: 10000
  #     retries: 10
  #     read_timeout: 10000
  #     write_timeout: 10000
#    route:
  #     methods:
  #     - POST
  #     - GET
  #     regex_priority: 0
  #     strip_path: false
  #     preserve_host: true
  #     protocols:
  #     - http
  #     - https


resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #  cpu: 100m
  #  memory: 128Mi
  # requests:
  #  cpu: 100m
  #  memory: 128Mi

# enable autoscaling and set utilization targets.  For autoscaling on cpu/memeory to work you
# must set resource limits
autoscaling: {}
#autoscaling:
#  enabled: false
#  minReplicas: 2
#  maxReplicas: 5
#  targetCPUUtilizationPercentage: 50
#  targetMemoryUtilizationPercentage: 75

nodeSelector: {}

tolerations: []

affinity: {}


#Uncomment the snippet of values below to implement CloudSQL proxy for your implementation
#This sidecar implementation would effectively allow you to access your instance host with 'localhost'

# sidecar: |
#   - name: cloudsql-proxy
#     image: gcr.io/cloudsql-docker/gce-proxy:1.14
#     command: ["/cloud_sql_proxy",
#     "-instances=INSTANCE_CONNECTION_NAME=tcp:5432"]
#     securityContext:
#       runAsUser: 2  
#       allowPrivilegeEscalation: false    
#
#  replace INSTANCE_CONNECTION_NAME with your cloudsql instance ie cio-cio-lab-eugene-np-0cdac4:northamerica-northeast1:genesys-3b7fae0c

#prometheus:
#  enable: false
#  # scrapePath: "/mypath"
#  # scrapePort: 9000

#rbac:
#  create: false 
#  serviceAccountAnnotations: {
#    iam.gke.io/gcp-service-account: "ivr-intelligent-routing@cio-smart-ivr-np-4462cd.iam.gserviceaccount.com", 
#    foo: "bar"
#    }   
#  serviceAccountName: "chart-service-account"